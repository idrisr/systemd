\documentclass[openany, 12pt]{book}
\input{preamble}
\title{SystemD}
\author{Idris}
\date{June 2025}

%chktex-file 1
%chktex-file 12
%chktex-file 18

\input{glossary}
\makeglossaries

\begin{document}
\tableofcontents
% \listoftodos

\frontmatter
\chapter{Introduction}
Systemd is the unavoidable beast on Linux and NixOS. This is my attempt to
teach it to myself while producing a lasting artifact.

Systemd is PID~1, launched by the kernel and marking the entry to user space.
It manages a directed graph of \emph{units}, not just processes. Every process
has a parent, with systemd at the root of the user-space tree.

The nodes of this graph are units. Units are defined by unit files, collected
from known directories. Systemd parses them into a graph and executes it in
topological order, honoring dependencies while maximizing parallelism.

Some units spawn long-lived daemons, others represent timers, sockets, mounts,
targets, or devices. Systemd supervises them: processes may crash, and systemd
can restart them according to policy. It can also trigger units on events such
as socket activity, device appearance, path changes, timers, or D-Bus requests.

The process graph built by systemd contains many daemons listening on network
or Unix sockets. Systemd itself does not provide a discovery layer for these
services; DNS handles the network side, while D-Bus acts as the local discovery
and IPC bus.


\mainmatter
\chapter{Units}
\section{Service}
Service units are the work-horse of systemd. Only within service units, we have
a type argument.

\begin{definition}{Templated Units}{}
  Templated units in \texttt{systemd} are unit files whose names contain an
  \texttt{@} symbol, such as \texttt{myservice@\{instance\}.service}. They define
  a generic structure that can be instantiated with specific identifiers. When an
  instance like \texttt{myservice@foo.service} is started, the placeholder is
  replaced with \texttt{foo}, and the unit can refer to this instance string using
  \texttt{\%i} (or \texttt{\%I} for the unescaped form). This enables modular,
  reusable configurations across services or users.
\end{definition}

\begin{intuition}{Templated Unit}{}
  A templated unit is essentially a $\lambda$-abstraction over a systemd unit
  file. Applying it with an instance name produces a concrete unit named
  \texttt{unit@\textit{instance}.service}, where \textit{instance} is the
  argument.
\end{intuition}

\begin{table}[ht]
  \centering
  \rowcolors{2}{gray!10}{white}
  \begin{tabular}{@{}ll@{}}
    \toprule
    \textbf{Type}    & \textbf{Meaning}                                             \\
    \midrule
    \texttt{simple}  & Default. Start service and assume it's ready immediately.    \\
    \texttt{exec}    & Like \texttt{simple}, but tracks the real PID of the binary. \\
    \texttt{forking} & Assumes service forks; parent exits when setup is done.      \\
    \texttt{oneshot} & For short-lived commands (e.g. setup); blocks until done.    \\
    \texttt{notify}  & Waits for \texttt{READY=1} via \texttt{sd\_notify()}.        \\
    \texttt{dbus}    & Waits until service acquires a specific D-Bus name.          \\
    \bottomrule
  \end{tabular}
  \caption{Valid \texttt{Type=} values for \texttt{.service} units}
\end{table}

Use notify when you want to control when the unit is considered started based on
your custom logic.

\section{Socket}

\section{Timer}

\section{Target}
\begin{definition}{Target}{}
  Targets are grouping units in systemd. They have no associated process;
  their only role is to aggregate other units for synchronization and
  dependency management.
\end{definition}

A target is considered active when all of its Requires= or Wants= are started
in the systemd sense---activating, active, or deactivating.

It doesn’t run code. It doesn't have a process. It just becomes active as soon
as the units it gathers are active.

service
socket
device
mount
automount
swap
target
path
timer
slice
scope


\begin{table}[h]
  \centering
  \rowcolors{2}{gray!10}{white}
  \begin{tabular}{ll}
    \toprule
    \textbf{Target} & \textbf{Description}                              \\
    \midrule
    default         & Boot entry point; usually links to another target \\
    multi-user      & Non-graphical multi-user system (like runlevel 3) \\
    graphical       & Multi-user + graphical session (like runlevel 5)  \\
    rescue          & Single-user mode with essential services          \\
    emergency       & Minimal shell with almost nothing started         \\
    sysinit         & Early boot: mounts, udev, swap, tmpfiles          \\
    basic           & After sysinit; sockets, timers, dbus, etc.        \\
    network-online  & Network stack is fully configured                 \\
    shutdown        & Synchronization point during shutdown             \\
    \bottomrule
  \end{tabular}
  \caption{Key systemd targets and their purposes}
\end{table}

\begin{center}
  \rowcolors{2}{gray!10}{white}
  \begin{tabular}{lc}
    \toprule
    type      & resource control \\
    \midrule
    automount &                  \\
    device    &                  \\
    mount     &                  \\
    path      &                  \\
    scope     & \checkmark       \\
    service   & \checkmark       \\
    slice     & \checkmark       \\
    snapshot  &                  \\
    socket    &                  \\
    swap      &                  \\
    target    &                  \\
    timer     &                  \\
    \bottomrule
  \end{tabular}
\end{center}

\chapter{Unit Sections}
Every unit file is made up of sections. Different unit types will have different
subsets of the sections available, and some sections are available to all unit
types.

Each section is made up of different directives, which are key-value pair which
control how to the unit behaves. There are a ton of directives and sections, and
the tables below summarize the most common types of each you should know.

\begin{center}
  % \rowcolors{2}{gray!10}{white}
  \begin{tabular}{ll}
    \toprule
    \textbf{Section} & \textbf{Purpose / Key Directives}                                                                      \\
    \midrule
    \texttt{Unit}    & Metadata + dependencies. \texttt{Description=}, \texttt{Wants=}, \texttt{Requires=}, \texttt{After=}   \\
    \texttt{Install} & Enable/disable integration. \texttt{WantedBy=}, \texttt{RequiredBy=}                                   \\
    \texttt{Service} & Manage daemons / processes. \texttt{ExecStart=}, \texttt{ExecStop=}, \texttt{Restart=}, \texttt{User=} \\
    \texttt{Socket}  & Socket activation. \texttt{ListenStream=}, \texttt{ListenDatagram=}, \texttt{SocketMode=}              \\
    \texttt{Timer}   & Scheduling. \texttt{OnCalendar=}, \texttt{OnBootSec=}, \texttt{OnUnitActiveSec=}                       \\
    \bottomrule
  \end{tabular}
\end{center}

\begin{center}
  % \rowcolors{2}{gray!10}{white}
  \begin{tabular}{lll}
    \toprule
    \textbf{Section} & \textbf{Directive} & \textbf{Purpose}                         \\
    \midrule
    \textbf{Unit}
                     & Description        & Human-readable label                     \\
                     & Wants/Requires     & Declare weak/strong dependencies         \\
                     & After/Before       & Control ordering of start/stop           \\
    \midrule
    \textbf{Service}
                     & ExecStart          & Command to start the service             \\
                     & ExecStop           & Command to stop the service              \\
                     & Restart            & Restart policy                           \\
                     & User               & User account to run as                   \\
    \midrule
    \textbf{Install}
                     & WantedBy           & Targets the unit hooks into when enabled \\
    \midrule
    \textbf{Socket}
                     & ListenStream       & TCP/Unix socket to listen on             \\
                     & SocketMode         & File mode for the socket                 \\
    \midrule
    \textbf{Timer}
                     & OnCalendar         & Cron-like schedule                       \\
                     & OnBootSec          & Delay relative to boot                   \\
    \bottomrule
  \end{tabular}
\end{center}

\begin{center}
  % \rowcolors{2}{gray!10}{white}
  \begin{tabular}{ll}
    \toprule
    \textbf{Directive}  & \textbf{Purpose}                                        \\
    \midrule
    \multicolumn{2}{l}{\textbf{Core (80/20)}}                                     \\
    Description         & Human-readable label for the unit                       \\
    Wants/Requires      & Declare weak/strong dependencies                        \\
    After               & Ensure ordering of start/stop                           \\
    ExecStart           & Command to start the service                            \\
    ExecStop            & Command to stop the service                             \\
    Restart             & Restart policy (e.g., on-failure)                       \\
    User                & User account to run as                                  \\
    WorkingDirectory    & Working directory for the process                       \\
    WantedBy            & Targets this unit hooks into when enabled               \\
    ListenStream        & TCP/Unix stream socket to listen on                     \\
    SocketMode          & File mode (permissions) for the socket                  \\
    OnCalendar          & Cron-like time specification                            \\
    OnBootSec           & Delay relative to boot                                  \\
    OnUnitActiveSec     & Delay relative to last activation                       \\
    \midrule
    \multicolumn{2}{l}{\textbf{Advanced (sometimes needed)}}                      \\
    Type                & Service startup type (simple, forking, notify, oneshot) \\
    ExecReload          & Command to reload the service configuration             \\
    Environment         & Define environment variables for the service            \\
    EnvironmentFile     & Load environment variables from a file                  \\
    RemainAfterExit     & Keep service marked active after process exits          \\
    PIDFile             & Path to PID file for tracking service processes         \\
    TimeoutStartSec     & Max time to wait for start before failure               \\
    TimeoutStopSec      & Max time to wait for stop before kill                   \\
    ConditionPathExists & Only start if a given path exists                       \\
    Conflicts           & Ensure this unit and another cannot run simultaneously  \\
    Alias               & Alternative names for this unit when enabled            \\
    Also                & Enable/disable additional units together                \\
    \bottomrule
  \end{tabular}
\end{center}

% \rowcolors{2}{gray!10}{white}
\begin{tabular}{lll}
  \toprule
  \textbf{Forward}     & \textbf{Reverse}     & \textbf{Where used}          \\
  \midrule
  Before               & After                & Unit                         \\
  After                & Before               & Unit                         \\
  Requires             & RequiredBy           & Unit / Install               \\
  Wants                & WantedBy             & Unit / Install               \\
  Upholds              & UpheldBy             & Unit / Install               \\
  PartOf               & ConsistsOf           & Unit / automatic property    \\
  BindsTo              & BoundBy              & Unit / automatic property    \\
  Requisite            & RequisiteOf          & Unit / automatic property    \\
  Conflicts            & ConflictedBy         & Unit / automatic property    \\
  Triggers             & TriggeredBy          & Automatic properties         \\
  PropagatesReloadTo   & ReloadPropagatedFrom & Unit                         \\
  ReloadPropagatedFrom & PropagatesReloadTo   & Unit                         \\
  PropagatesStopTo     & StopPropagatedFrom   & Unit                         \\
  StopPropagatedFrom   & PropagatesStopTo     & Unit                         \\
  Following            & n/a                  & Automatic property (devices) \\
  \bottomrule
\end{tabular}

\begin{definition}{Service Section}{}
  Let $u \in U$ be a systemd unit of type \texttt{.service}.

  The \texttt{[Service]} section defines the **execution behavior** of $u$:
  a finite map
  \begin{align*}
    \text{Service} : K \to V
  \end{align*}
  where $K$ is a set of predefined keys (e.g. \texttt{ExecStart}, \texttt{Restart}),
  and $V$ are values interpreted by systemd at runtime.

  This section governs the transition behavior of the unit’s state predicate $\mathsf{started}(u)$,
  including:
  \begin{itemize}
    \item when and how the unit is started
    \item what process it runs
    \item what happens on failure
  \end{itemize}
\end{definition}

\begin{definition}{Section}{}
  A logical partition of a systemd unit file in INI format. Each section
  groups related directives. Common sections include \texttt{[Unit]},
  \texttt{[Service]}, and \texttt{[Install]}.
\end{definition}

\begin{definition}{Unit}{}
  Generic metadata and dependency configuration. Typical directives:
  \texttt{Description=}, \texttt{Wants=}, \texttt{Requires=}, \texttt{After=}.
\end{definition}

\begin{definition}{Install}{}
  Defines how the unit integrates into the system when enabled or disabled.
  Most commonly uses \texttt{WantedBy=} or \texttt{RequiredBy=}.
\end{definition}

\begin{definition}{Service}{}
  Controls how a service (daemon or process) is started, stopped, and
  restarted. Key directives: \texttt{ExecStart=}, \texttt{ExecStop=},
  \texttt{Restart=}, \texttt{User=}.
\end{definition}

\begin{definition}{Socket}{}
  Configures socket activation, where systemd listens on a socket and
  activates the matching service on demand. Common directives:
  \texttt{ListenStream=}, \texttt{ListenDatagram=}, \texttt{SocketMode=}.
\end{definition}

\begin{definition}{Timer}{}
  Schedules units based on time or activity. Directives include
  \texttt{OnCalendar=}, \texttt{OnBootSec=}, \texttt{OnUnitActiveSec=}.
\end{definition}

\begin{definition}{directive}{}
  A single key--value instruction inside a unit section. Directives tell
  systemd how to configure or control behavior. For example,
  \texttt{Description=}, \texttt{ExecStart=}, and \texttt{WantedBy=} are
  directives. Each section has its own set of valid directives, and
  systemd ignores unknown ones.
\end{definition}


\chapter{Relations}

\adjustbox{scale=1.5, center}{
  \begin{tikzcd}
    \text{Unit A} \arrow[r, bend left=40, "Wants="] & \text{Unit B} \arrow[l, bend left=40, dashed, "WantedBy="]
  \end{tikzcd}
}

\begin{enumerate}[label = {(\arabic*)}]
  \item Wants
  \item Requires
  \item Before
  \item After
  \item Conflicts
\end{enumerate}

\begin{definition}{unit states}{}
  Let $S$ be the set of possible states of a unit:
  \begin{align*}
    S = \set{ \mathsf{inactive},\ \mathsf{activating},\ \mathsf{active},\ \mathsf{deactivating},\ \mathsf{failed}}
  \end{align*}
  Define a state function
  \begin{align*}
    a : U \to S
  \end{align*}
  which maps each unit to its current state.
\end{definition}

\begin{definition}{started predicate}{}
  Let
  \begin{align*}
    \mathsf{started}(u) \iff a(u) \in \set{ \mathsf{activating},\ \mathsf{active},\ \mathsf{deactivating}}
  \end{align*}
  This captures units that are in the process of starting, running, or
  stopping — i.e., **not inactive or failed**.
\end{definition}

\section{Wants}
\begin{definition}{wants predicate}{}
  Given a relation
  \begin{align*}
    \text{Wants} \subseteq U \times U
  \end{align*}
  we define the systemd behavior as:

  \begin{quote}
    If $\mathsf{started}(a)$ becomes true, then for each $(a, b) \in
      \text{Wants}$, systemd attempts $\mathsf{start}(b)$, regardless of
    whether $\mathsf{start}(b)$ eventually succeeds or fails.
  \end{quote}

  This defines ``Wants'' as a rule over the state predicate $\mathsf{started}$,
  rather than an abstract dependency graph.

  A weaker form of Requires: unit is started if any in the list fail.
\end{definition}

\section{WantedBy}
\begin{definition}{wantedby predicate}{}
  Given the same relation
  \begin{align*}
    \text{Wants} \subseteq U \times U
  \end{align*}
  we define
  \begin{align*}
    \text{WantedBy}(b) := \{ a \in U \mid (a, b) \in \text{Wants} \}
  \end{align*}
  as the *reverse mapping* of the ``Wants'' relation. In unit files, specifying
  \texttt{WantedBy=target} means that \texttt{(target, unit)} is added to the
  ``Wants'' relation.

  This declaration is used to construct the dependency graph at install time,
  via \texttt{systemctl enable}.

  Mostly used for targets.
\end{definition}

\section{Requires}
\begin{definition}{requires predicate}{}
  list of units this unit depends on which must be started as well.
\end{definition}

\section{Conflicts}
\begin{definition}{conflicts predicate}{}
  list of units this unit depends on which must be started as well.
\end{definition}

\section{After}
\begin{definition}{after predicate}{}
  Given a relation
  \begin{align*}
    \text{After} \subseteq U \times U
  \end{align*}
  we define the systemd behavior as:

  \begin{quote}
    If $(a, b) \in \text{After}$, then systemd ensures that if both $a$ and
    $b$ are scheduled to start, then $\mathsf{start}(b)$ completes
    (successfully or not) before $\mathsf{start}(a)$ begins.
  \end{quote}

  This relation governs start-time ordering but imposes no dependency: systemd
  does not automatically start $b$ when starting $a$.

  Thus, ``After'' is a partial order constraint on the timeline of unit
  startups, orthogonal to dependency relations like ``Wants''.
\end{definition}




\chapter{Ordering}

Some of the relations form the dependency graph. Then for any node, we can
create a closure over the set of dependent nodes. Then from that closure we can
create a time ordering.

\section{Unit Relations}

% \todo[inline]{Improve the order definitions using predicates over the states}
\begin{definition}{Topological Order}{}
  A topological order is a total ordering over a subset of units such that for
  any
  \begin{align*}
    (a, b) \in R \subseteq U \times U,
  \end{align*}
  if $a$ must causally precede $b$ (e.g., via \texttt{Wants} or \texttt{Requires}),
  then $a$ appears before $b$ in the ordering.

  This applies when $R$ forms a directed acyclic graph (DAG), and is used to
  compute valid execution sequences from dependency relations.
\end{definition}

\begin{definition}{Time Order}{}
  A time order is a scheduling constraint over unit startup.

  Given
  \begin{align*}
    (a, b) \in R \subseteq U \times U,
  \end{align*}
  the relation enforces that if both $a$ and $b$ are scheduled to start, then
  $\mathsf{start}(a)$ is delayed until $\mathsf{start}(b)$ has finished
  (successfully or not).

  Time order does not imply dependency; it only constrains relative ordering.
\end{definition}

\begin{definition}{Lifetime Binding}{}
  A lifetime binding is a coupling between the runtime lifecycles of units.

  Given
  \begin{align*}
    (a, b) \in R \subseteq U \times U,
  \end{align*}
  the relation enforces that events in the lifetime of $b$ (e.g., stopping,
  restarting) propagate to $a$.

  Examples include \texttt{BindsTo} (stop cascades) and \texttt{PartOf}
  (restart cascades).
\end{definition}

\begin{table}[h]
  \centering
  \rowcolors{2}{gray!10}{white}
  \begin{tabular}{lccc l}
    \toprule
    \textbf{Relation} & \textbf{Topo.} & \textbf{Time} & \textbf{Bind / Reverse} & \textbf{Note}            \\
    \midrule
    Wants             & \checkmark     &               &                         & Soft dependency          \\
    Requires          & \checkmark     &               &                         & Hard dependency (fatal)  \\
    Requisite         & \checkmark     &               &                         & Must succeed pre-start   \\
    Conflicts         & \checkmark     &               &                         & Mutual exclusion         \\
    After             &                & \checkmark    &                         & Starts after if present  \\
    Before            &                & \checkmark    &                         & Starts before if present \\
    BindsTo           &                &               & \checkmark              & Stop cascades            \\
    PartOf            &                &               & \checkmark              & Restart/stop cascades    \\
    JoinsNamespaceOf  &                &               & \checkmark              & Shares runtime namespace \\
    RequiredBy        &                &               & $\leftarrow$            & Reverse dependency       \\
    \bottomrule
  \end{tabular}
  \caption{Systemd relations classified by axis with compact notes}
\end{table}


Let $U$ be the finite set of all systemd units.

We define three fundamental binary relations on $U \times U$:

\begin{align*}
  \text{Wants}   & \subseteq U \times U &  & \text{(Dependency)}        \\
  \text{After}   & \subseteq U \times U &  & \text{(Time Ordering)}     \\
  \text{BindsTo} & \subseteq U \times U &  & \text{(Lifecycle Binding)}
\end{align*}

\begin{description}
  \item[Wants:] If $(a, b) \in \text{Wants}$, then starting $a$ causes systemd
        to attempt to start $b$. No ordering is implied.

  \item[After:] If $(a, b) \in \text{After}$, and both $a$ and $b$ are being
        started, then systemd delays starting $a$ until after $b$ has finished
        starting (success or failure).

  \item[BindsTo:] If $(a, b) \in \text{BindsTo}$, then stopping $b$ causes
        systemd to stop $a$. The lifecycle of $a$ is bound to that of $b$.
\end{description}


\chapter{Targets}

\begin{definition}{target}{}
  \begin{alist}
    \item unit that lists dependencies on other targets
  \end{alist}
\end{definition}

\begin{tabular}{@{}ll@{}}
  \toprule
  \textbf{Target}                & \textbf{Purpose}                                                 \\
  \midrule
  \texttt{default.target}        & Main entry point after boot (usually symlinks to another target) \\
  \texttt{multi-user.target}     & Non-graphical system, networking, users, services                \\
  \texttt{graphical.target}      & Like multi-user + graphical session (e.g. display manager)       \\
  \texttt{network.target}        & Basic network stack is up (may be too early for apps)            \\
  \texttt{network-online.target} & Network is fully configured (for apps needing connectivity)      \\
  \texttt{sysinit.target}        & Early boot initialization (mounts, swap, etc.)                   \\
  \texttt{basic.target}          & After sysinit; before most services                              \\
  \texttt{rescue.target}         & Single-user mode with minimal services                           \\
  \texttt{emergency.target}      & Minimal shell, no services (critical recovery)                   \\
  \bottomrule
\end{tabular}



\begin{table}
  \begin{tabular}{ll}
    \toprule
    \textbf{Option}                & \textbf{Description}                                                                            \\
    \midrule
    \texttt{CapabilityBoundingSet} & Limits kernel capabilities available to the service.                                            \\
    \texttt{DynamicUser}           & a transient user at runtime, Removed when the service stops.                                    \\
    \texttt{InaccessiblePaths}     & Makes specific paths inaccessible.                                                              \\
    \texttt{PrivateDevices}        & Restricts access to physical devices.                                                           \\
    \texttt{PrivateNetwork}        & Isolates in private network namespace.                                                          \\
    \texttt{PrivateTmp}            & Isolates \texttt{/tmp} and \texttt{/var/tmp} for the service.                                   \\
    \texttt{PrivateUsers}          & Hides the system’s user table from the service.                                                 \\
    \texttt{ProtectControlGroups}  & Prevents manipulating cgroups from inside the service.                                          \\
    \texttt{ProtectHome}           & Restricts access to user home directories.                                                      \\
    \texttt{ProtectKernelTunables} & Prevents modifying kernel tunables in \texttt{/proc/sys} and similar.                           \\
    \texttt{ProtectSystem}         & Makes parts of the file system read-only. Values: \texttt{yes}, \texttt{full}, \texttt{strict}. \\
    \texttt{ReadOnlyPaths}         & Makes specific paths read-only.                                                                 \\
    \texttt{RootDirectory}         & Changes the root directory for the service (like \texttt{chroot}).                              \\
    \texttt{User}                  & Runs service as specified (existing) user.                                                      \\
    \bottomrule
  \end{tabular}
  \caption{Sandbox protection available}
\end{table}

\chapter{Design Patterns}
\section{If This Then That}
Many systemd units follow an *if-then* structure, where the *then* is a
\texttt{.service} unit, and the *if* is an event unit. Common event types include
\texttt{.path} (file changes), \texttt{.mount} (mount state changes),
\texttt{.socket} (socket activation), \texttt{.timer} (scheduled time),
and \texttt{.device} (hardware changes). These trigger the corresponding
service via the \texttt{Unit=} directive.

\section{After plus Wants}
The ``wants'' relation

\begin{table}[h]
  \centering
  \begin{tabular}{@{}lll@{}}
    \toprule
    \textbf{Description}          & \textbf{Path}                                            & \textbf{Scope} \\ \midrule
    Admin overrides (persistent)  & \texttt{/etc/systemd/system/}                            & System         \\
    Runtime overrides (temporary) & \texttt{/run/systemd/system/}                            & System         \\
    Package default units         & \texttt{/lib/systemd/system/} or \texttt{/nix/store/...} & System         \\
    User config overrides         & \texttt{\$XDG\_CONFIG\_HOME/systemd/user/}               & User           \\
    User runtime units            & \texttt{\$XDG\_RUNTIME\_DIR/systemd/user/}               & User           \\
    User package units            & \texttt{\$XDG\_DATA\_DIRS/systemd/user/}                 & User           \\
    \bottomrule
  \end{tabular}
  \caption{systemd unit file lookup hierarchy}
\end{table}

\begin{table}[ht]
  \begin{tabular}{lll}
    \toprule
    \textbf{Unit File}              & \textbf{Type}     & \textbf{Description}                                        \\
    \midrule
    \texttt{systemd-journald}       & \texttt{.service} & Collects and stores log messages.                           \\
    \texttt{systemd-logind}         & \texttt{.service} & Manages user logins and sessions.                           \\
    \texttt{systemd-udevd}          & \texttt{.service} & Handles dynamic device events and creates device nodes.     \\
    \texttt{systemd-networkd}       & \texttt{.service} & Configures and manages network interfaces.                  \\
    \texttt{systemd-resolved}       & \texttt{.service} & DNS and name resolution.                                    \\
    \texttt{systemd-timesyncd}      & \texttt{.service} & Synchronizes system clock with remote NTP servers.          \\
    \texttt{systemd-homed}          & \texttt{.service} & Manages home directories with user records.                 \\
    \texttt{systemd-tmpfiles-setup} & \texttt{.service} & Creates, cleans up, and manages volatile files/directories. \\
    systemctl                       & \texttt{binary}   & cli tool to control the systemd manager and units.          \\
    \bottomrule
  \end{tabular}
  \caption{Systemd tools}
\end{table}

\begin{table}[h]
  \centering
  \rowcolors{2}{gray!10}{white}
  \begin{tabular}{llc}
    \toprule
    \textbf{Man Page}           & \textbf{Purpose}                                                                & \textbf{Read} \\
    \midrule
    \texttt{systemd.unit}       & core unit file structure; shared options across all unit types.                 & \checkmark    \\
    \texttt{systemd.service}    & service-specific unit options (e.g., \texttt{ExecStart}, \texttt{Restart}).     &               \\
    \texttt{systemd.target}     & describes target units and boot targets like \texttt{multi-user.target}.        &               \\
    \texttt{systemd.special}    & magic units with reserved semantics (e.g., \texttt{default}, \texttt{sysinit}). &               \\
    \texttt{systemd.timer}      & timer units, scheduling and activation (cron replacement).                      &               \\
    \texttt{systemd.socket}     & socket-activated services and socket units.                                     &               \\
    \texttt{systemd.path}       & path-based activation (run service when file appears/changes).                  &               \\
    \texttt{systemctl}          & cli interface to start, stop, enable, inspect units.                            &               \\
    \texttt{systemd-analyze}    & tool for analyzing boot times, unit ordering, and critical chains.              &               \\
    \texttt{systemd.exec}       & execution environment: working dir, env vars, i/o redirection, etc.             &               \\
    \texttt{systemd.directives} & lookup table of all directives and which man page defines them.                 &               \\
    \texttt{bootup}             & high-level boot process and target flow overview.                               &               \\
    \bottomrule
  \end{tabular}
  \caption{The 80/20 systemd man pages: enough to master unit configuration and runtime control.}
\end{table}

\begin{table}
  \begin{center}
    \rowcolors{2}{gray!10}{white}
    \begin{tabular}{lll}
      \toprule
      Phase            & Purpose                                & Sections used                        \\
      \midrule
      Parse / Load     & systemd reads unit definitions, builds & \texttt{[Unit]}, \texttt{[Service]}, \\
                       & dependency graph                       & \texttt{[Socket]}, etc.              \\
      Enable / Disable & \texttt{systemctl enable/disable} sets & \texttt{[Install]} only              \\
                       & up symlinks for automatic start        &                                      \\
      Activation       & starting, stopping, ordering units at  & \texttt{[Unit]} (ordering, deps),    \\
                       & runtime                                & type-specific section                \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

\begin{center}
  \begin{tabular}{lll}
    \toprule
    Source              & Location / Example                              & Precedence                    \\
    \midrule
    Vendor unit         & /usr/lib/systemd/system/foo.service             & Lowest                        \\
    System override     & /etc/systemd/system/foo.service                 & Replaces vendor file entirely \\
    Drop-in (vendor)    & /usr/lib/systemd/system/foo.service.d/*.conf    & Applied on top of base        \\
    Drop-in (system)    & /etc/systemd/system/foo.service.d/*.conf        & Higher than vendor drop-ins   \\
    Drop-in (user edit) & systemctl edit foo.service →                    & Highest; merged last          \\
                        & /etc/systemd/system/foo.service.d/override.conf &                               \\
    \bottomrule
  \end{tabular}
\end{center}

\chapter{Systemctl}

\begin{center}
  \begin{tabular}{ll}
    \toprule
    Category      & Key Commands                                                                                                          \\
    \midrule
    Unit          & \texttt{list-units}, \texttt{status}, \texttt{show}, \texttt{start}, \texttt{stop}, \texttt{restart}, \texttt{reload} \\
    Unit File     & \texttt{list-unit-files}, \texttt{enable}, \texttt{disable}, \texttt{mask}, \texttt{unmask}, \texttt{edit}            \\
    Machine       & \texttt{list-machines}, \texttt{show-machine}                                                                         \\
    Job           & \texttt{list-jobs}, \texttt{cancel}                                                                                   \\
    Environment   & \texttt{show-environment}, \texttt{set-environment}, \texttt{unset-environment}                                       \\
    Manager State & \texttt{daemon-reexec}, \texttt{daemon-reload}, \texttt{is-system-running}                                            \\
    System        & \texttt{poweroff}, \texttt{reboot}, \texttt{suspend}, \texttt{hibernate}, \texttt{halt}                               \\
    \bottomrule
  \end{tabular}
\end{center}


\begin{longtable}{lll}
  \toprule
  Category      & Verb                   & Description                             \\
  \midrule
  \endfirsthead

  \toprule
  Category      & Verb                   & Description                             \\
  \midrule
  \endhead

  \midrule
  \multicolumn{3}{r}{\small\emph{Continued on next page}}                          \\
  \midrule
  \endfoot

  \bottomrule
  \endlastfoot

  Unit control  & list-units             & List active units                       \\
                & status                 & Show runtime status of a unit           \\
                & show                   & Show raw properties of a unit           \\
                & start                  & Start (activate) a unit                 \\
                & stop                   & Stop (deactivate) a unit                \\
                & restart                & Start or restart a unit                 \\
                & reload                 & Reload configuration of a unit          \\
                & try-restart            & Restart if unit is active               \\
                & kill                   & Send a signal to unit processes         \\
                & reset-failed           & Clear failed state of units             \\
  \midrule
  Unit File     & list-unit-files        & List installed unit files               \\
                & enable                 & Enable a unit (create symlink)          \\
                & disable                & Disable a unit (remove symlink)         \\
                & reenable               & Disable and re-enable a unit            \\
                & mask                   & Make a unit unstartable (→ /dev/null)   \\
                & unmask                 & Remove mask from a unit                 \\
                & edit                   & Edit or override a unit file            \\
                & preset                 & Enable/disable by preset policy         \\
                & preset-all             & Apply presets to all units              \\
                & revert                 & Revert to vendor version                \\
                & link                   & Link a unit file into search path       \\
                & is-enabled             & Check if a unit is enabled              \\
  \midrule
  Jobs          & list-jobs              & List jobs queued by systemd             \\
                & cancel                 & Cancel jobs                             \\
  \midrule
  Machines      & list-machines          & List host + local containers            \\
                & show-machine           & Show machine properties                 \\
  \midrule
  Environment   & show-environment       & Show environment variables              \\
                & set-environment        & Define environment variables            \\
                & unset-environment      & Remove environment variables            \\
                & import-environment     & Import environment from shell           \\
  \midrule
  Manager state & daemon-reexec          & Restart systemd manager itself          \\
                & daemon-reload          & Reload unit files/config in manager     \\
                & is-system-running      & Show overall system state               \\
                & log-level              & Get/set manager log level               \\
                & log-target             & Get/set manager log target              \\
                & service-watchdogs      & Get/set service watchdogs               \\
  \midrule
  System state  & default                & Switch to default target                \\
                & isolate                & Start one unit, stop all others         \\
                & get-default            & Show current default target             \\
                & set-default            & Set default target                      \\
                & poweroff               & Power off system                        \\
                & reboot                 & Reboot system                           \\
                & halt                   & Halt system                             \\
                & exit                   & Terminate user instance                 \\
                & rescue                 & Enter rescue mode                       \\
                & emergency              & Enter emergency mode                    \\
                & suspend                & Suspend to RAM                          \\
                & hibernate              & Suspend to disk                         \\
                & hybrid-sleep           & Suspend + hibernate                     \\
                & suspend-then-hibernate & Suspend, then hibernate later           \\
                & soft-reboot            & Reboot userspace only                   \\
                & kexec                  & Reboot via kexec                        \\
                & switch-root            & Switch root filesystem                  \\
  \midrule
  helpers       & bind                   & Bind mount a path into a unit namespace \\
                & mount-image            & Mount image into a unit namespace       \\
                & cat                    & Show unit file sources and drop-ins     \\
                & clean                  & Remove unit state/cache/logs            \\
                & help                   & Show documentation for units            \\
                & whoami                 & Show which unit invoked a command       \\
                & list-dependencies      & Show dependency tree                    \\
                & list-sockets           & List socket units                       \\
                & list-timers            & List timer units                        \\
                & list-paths             & List path units                         \\
                & list-automounts        & List automount units                    \\
                & service-log-level      & Get/set logging level for service       \\
                & service-log-target     & Get/set logging target for service      \\
                & set-property           & Change unit properties at runtime       \\
                & add-wants              & Add Wants= edge to a unit               \\
                & add-requires           & Add Requires= edge to a unit            \\
\end{longtable}

\glsaddallunused{}

\clearpage
\printglossaries

% \printbibliography{}
% \printindex{}
\end{document}
